<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Base Graphics System Test</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Custom Styles -->
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #e5e7eb;
        }
        
        #map {
            height: 100vh;
            width: 100vw;
        }
        
        .test-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #8b5cf6;
        }
        
        .test-controls h3 {
            margin: 0 0 15px 0;
            color: #8b5cf6;
        }
        
        .test-controls button {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 10px;
            background: linear-gradient(135deg, #8b5cf6, #3b82f6);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .test-controls button:hover {
            background: linear-gradient(135deg, #7c3aed, #2563eb);
        }
        
        .test-controls select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: #1a1a2e;
            color: #e5e7eb;
            border: 1px solid #8b5cf6;
            border-radius: 5px;
        }
        
        .test-controls input {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: #1a1a2e;
            color: #e5e7eb;
            border: 1px solid #8b5cf6;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="test-controls">
        <h3>ğŸ¨ SVG Base Graphics Test</h3>
        
        <label>Flag Type:</label>
        <select id="flagType">
            <option value="finnish">Finnish ğŸ‡«ğŸ‡®</option>
            <option value="swedish">Swedish ğŸ‡¸ğŸ‡ª</option>
        </select>
        
        <label>Primary Color:</label>
        <input type="color" id="primaryColor" value="#8b5cf6">
        
        <label>Secondary Color:</label>
        <input type="color" id="secondaryColor" value="#3b82f6">
        
        <label>Accent Color:</label>
        <input type="color" id="accentColor" value="#f59e0b">
        
        <label>Energy Color:</label>
        <input type="color" id="energyColor" value="#10b981">
        
        <button onclick="createTestBase()">ğŸ—ï¸ Create Test Base</button>
        <button onclick="createRandomBases()">ğŸ² Create Random Bases</button>
        <button onclick="clearAllBases()">ğŸ—‘ï¸ Clear All Bases</button>
        <button onclick="testAnimations()">âœ¨ Test Animations</button>
        <button onclick="testCustomization()">ğŸ¨ Test Customization</button>
        <button onclick="testZoomScaling()">ğŸ” Test Zoom Scaling</button>
        <button onclick="testManualScaling()">ğŸ§ª Test Manual Scaling</button>
        <button onclick="updateAllBases()">ğŸ”„ Update All Bases</button>
        <button onclick="testZoomEvents()">ğŸ” Test Zoom Events</button>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- SVG Base Graphics System -->
    <script src="js/svg-base-graphics.js"></script>
    
    <script>
        let map;
        let svgGraphics;
        let testBases = [];
        
        // Initialize map
        function initMap() {
            map = L.map('map').setView([60.1699, 24.9384], 13); // Helsinki
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);
            
            console.log('ğŸ—ºï¸ Map initialized');
        }
        
        // Initialize SVG graphics system
        function initSVGGraphics() {
            svgGraphics = new SVGBaseGraphics();
            console.log('ğŸ¨ SVG Base Graphics system initialized');
        }
        
        // Create test base at current map center
        function createTestBase() {
            const center = map.getCenter();
            const flagType = document.getElementById('flagType').value;
            const primaryColor = document.getElementById('primaryColor').value;
            const secondaryColor = document.getElementById('secondaryColor').value;
            const accentColor = document.getElementById('accentColor').value;
            const energyColor = document.getElementById('energyColor').value;
            
            const config = {
                colors: {
                    primary: primaryColor,
                    secondary: secondaryColor,
                    accent: accentColor,
                    energy: energyColor
                }
            };
            
            const marker = svgGraphics.createAnimatedBaseMarker(
                { lat: center.lat, lng: center.lng },
                config,
                flagType,
                map // Pass the map instance for zoom detection
            );
            
            marker.addTo(map);
            testBases.push(marker);
            
            console.log('ğŸ—ï¸ Test base created with custom colors and zoom-appropriate size');
        }
        
        // Create random bases around the map
        function createRandomBases() {
            const center = map.getCenter();
            const flagTypes = ['finnish', 'swedish'];
            const colors = [
                { primary: '#8b5cf6', secondary: '#3b82f6', accent: '#f59e0b', energy: '#10b981' },
                { primary: '#dc2626', secondary: '#b91c1c', accent: '#fbbf24', energy: '#34d399' },
                { primary: '#059669', secondary: '#047857', accent: '#f59e0b', energy: '#8b5cf6' },
                { primary: '#7c2d12', secondary: '#92400e', accent: '#fbbf24', energy: '#10b981' }
            ];
            
            for (let i = 0; i < 5; i++) {
                const lat = center.lat + (Math.random() - 0.5) * 0.01;
                const lng = center.lng + (Math.random() - 0.5) * 0.01;
                const flagType = flagTypes[Math.floor(Math.random() * flagTypes.length)];
                const colorSet = colors[Math.floor(Math.random() * colors.length)];
                
                const config = {
                    colors: colorSet
                };
                
                const marker = svgGraphics.createAnimatedBaseMarker(
                    { lat: lat, lng: lng },
                    config,
                    flagType,
                    map // Pass the map instance for zoom detection
                );
                
                marker.addTo(map);
                testBases.push(marker);
            }
            
            console.log('ğŸ² Created 5 random bases');
        }
        
        // Clear all test bases
        function clearAllBases() {
            testBases.forEach(marker => {
                map.removeLayer(marker);
            });
            testBases = [];
            console.log('ğŸ—‘ï¸ All test bases cleared');
        }
        
        // Test animation toggles
        function testAnimations() {
            if (testBases.length === 0) {
                alert('Create some bases first!');
                return;
            }
            
            const baseData = svgGraphics.getAllBaseMarkers();
            baseData.forEach((data, markerId) => {
                const newConfig = {
                    animations: {
                        territoryPulse: Math.random() > 0.5,
                        flagWave: Math.random() > 0.5,
                        particleEffects: Math.random() > 0.5,
                        energyGlow: Math.random() > 0.5
                    }
                };
                
                svgGraphics.updateBaseMarker(markerId, newConfig);
            });
            
            console.log('âœ¨ Animation states randomized');
        }
        
        // Test customization
        function testCustomization() {
            if (testBases.length === 0) {
                alert('Create some bases first!');
                return;
            }
            
            const baseData = svgGraphics.getAllBaseMarkers();
            const colors = [
                { primary: '#8b5cf6', secondary: '#3b82f6', accent: '#f59e0b', energy: '#10b981' },
                { primary: '#dc2626', secondary: '#b91c1c', accent: '#fbbf24', energy: '#34d399' },
                { primary: '#059669', secondary: '#047857', accent: '#f59e0b', energy: '#8b5cf6' }
            ];
            
            baseData.forEach((data, markerId) => {
                const colorSet = colors[Math.floor(Math.random() * colors.length)];
                const newConfig = {
                    colors: colorSet,
                    size: 200 + Math.random() * 100 // Random size between 200-300
                };
                
                svgGraphics.updateBaseMarker(markerId, newConfig);
            });
            
            console.log('ğŸ¨ Base customization applied');
        }
        
        // Test zoom scaling
        function testZoomScaling() {
            if (testBases.length === 0) {
                alert('Create some bases first!');
                return;
            }
            
            // Cycle through different zoom levels to demonstrate scaling
            // From whole world view to street level
            const zoomLevels = [1, 3, 6, 9, 12, 15, 18];
            let currentIndex = 0;
            
            const cycleZoom = () => {
                if (currentIndex < zoomLevels.length) {
                    const zoomLevel = zoomLevels[currentIndex];
                    map.setZoom(zoomLevel);
                    
                    // Calculate expected scale for this zoom level
                    const minZoom = 1, maxZoom = 18;
                    const minScale = 0.1, maxScale = 1.0;
                    let expectedScale;
                    
                    if (zoomLevel <= minZoom) {
                        expectedScale = minScale;
                    } else if (zoomLevel >= maxZoom) {
                        expectedScale = maxScale;
                    } else {
                        const zoomRange = maxZoom - minZoom;
                        const scaleRange = maxScale - minScale;
                        const zoomProgress = (zoomLevel - minZoom) / zoomRange;
                        expectedScale = minScale + (scaleRange * zoomProgress);
                    }
                    
                    const expectedSize = Math.round(240 * expectedScale);
                    
                    console.log(`ğŸ” Zoom level: ${zoomLevel} | Expected scale: ${expectedScale.toFixed(2)} | Expected size: ${expectedSize}px`);
                    currentIndex++;
                    setTimeout(cycleZoom, 2500); // Wait 2.5 seconds between zoom changes
                } else {
                    // Return to original zoom
                    map.setZoom(13);
                    console.log('ğŸ” Zoom scaling test complete - returned to original zoom');
                }
            };
            
            console.log('ğŸ” Starting zoom scaling test...');
            console.log('ğŸ” Watch how bases get smaller when zoomed out (whole world) and larger when zoomed in (street level)');
            cycleZoom();
        }
        
        // Test manual scaling
        function testManualScaling() {
            if (testBases.length === 0) {
                alert('Create some bases first!');
                return;
            }
            
            const baseData = svgGraphics.getAllBaseMarkers();
            const markerIds = Array.from(baseData.keys());
            
            if (markerIds.length === 0) {
                alert('No base markers found!');
                return;
            }
            
            // Test different zoom levels manually
            const testZoomLevels = [1, 5, 10, 15, 18];
            let currentIndex = 0;
            
            const testNextZoom = () => {
                if (currentIndex < testZoomLevels.length) {
                    const zoomLevel = testZoomLevels[currentIndex];
                    
                    // Apply manual scaling to all markers
                    markerIds.forEach(markerId => {
                        svgGraphics.testScaling(markerId, zoomLevel);
                    });
                    
                    console.log(`ğŸ§ª Manual scaling test - Zoom level: ${zoomLevel}`);
                    currentIndex++;
                    setTimeout(testNextZoom, 2000);
                } else {
                    console.log('ğŸ§ª Manual scaling test complete');
                }
            };
            
            console.log('ğŸ§ª Starting manual scaling test...');
            testNextZoom();
        }
        
        // Update all existing bases to current zoom level
        function updateAllBases() {
            if (testBases.length === 0) {
                alert('Create some bases first!');
                return;
            }
            
            console.log('ğŸ”„ Manually updating all base scaling...');
            svgGraphics.updateAllBaseScaling();
        }
        
        // Test zoom event detection
        function testZoomEvents() {
            if (testBases.length === 0) {
                alert('Create some bases first!');
                return;
            }
            
            console.log('ğŸ” Testing zoom event detection...');
            svgGraphics.testZoomEvents();
        }
        
        // Initialize everything when page loads
        window.addEventListener('load', () => {
            initMap();
            initSVGGraphics();
            console.log('ğŸš€ SVG Base Graphics Test Page Ready!');
        });
    </script>
</body>
</html>
